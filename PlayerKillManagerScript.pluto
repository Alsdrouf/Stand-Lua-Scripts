util.require_natives('2944b')

local CEventNetworkEntityDamage = 186

local allKillsRoot
local playersRoot
local notificationsManager
local settingsManager
local eventManager
local playersManager

-- Reverse hash function
function foundWeaponWithHash(weaponHash: int): void
    for util.get_weapons() as weapon do
        if weapon['hash'] == weaponHash then
            return weapon
        end
    end
end

function foundVehicleWithHash(vehicleHash: int): void
    for util.get_vehicles() as vehicle do
        if vehicle['hash'] == vehicleHash then
            return vehicle
        end
    end
end

-- Translation
pluto_class Translation
    function __construct(lang: string, fallback: string): userdata
        self.lang = lang
        self.fallback = fallback
        self.translations = {}
    end

    function setLang(lang: string): void
        self.lang = lang
    end

    function getLang(): string
        return self.lang
    end

    function _translate(key: string, lang: string, params): string
        if self.translations[lang] == nil or self.translations[lang][key] == nil then
            if lang == self.fallback then
                util.toast('Missing translation key : ' .. key)
                return key
            else
                return self:_translate(key, self.fallback, params)
            end
        end
        local translation = self.translations[lang][key]
        if params ~= nil then
            for key, value in params do
                translation = translation:gsub('%%' .. key .. '%%', value)
            end
        end
        return translation
    end

    function translate(key: string, params): string
        return self:_translate(key, self.lang, params)
    end

    function register(key: string, lang: string, translation: string): void
        if self.translations[lang] == nil then
            self.translations[lang] = {}
        end
        self.translations[lang][key] = translation
    end
end

enum Lang begin
    ENGLISH,
    SPANISH_CASTILIAN
end

local t = pluto_new Translation(Lang.ENGLISH, Lang.ENGLISH)

-- English
--- Usefull
t:register('goToPlayerTabs', Lang.ENGLISH, 'Go to player tabs')
t:register('killRoot', Lang.ENGLISH, '%player1% > %player2%')
t:register('scriptName', Lang.ENGLISH, SCRIPT_NAME)
t:register('language', Lang.ENGLISH, 'Language')
t:register('language.description', Lang.ENGLISH, 'Set languages')
t:register('english', Lang.ENGLISH, 'English')
t:register('spanishCastilian', Lang.ENGLISH, 'Spanish (Castilian)')

--- Notifications
t:register('notifications', Lang.ENGLISH, 'Notifications')
t:register('notifications.description', Lang.ENGLISH, 'Manage notifications of players kill manager script')
t:register('enabled', Lang.ENGLISH, 'Enabled')
t:register('enabled.description', Lang.ENGLISH, 'Enable notifications of players kill manager script')
t:register('enabledOnGettingKilled', Lang.ENGLISH, 'Enabled on getting killed')
t:register('enabledOnGettingKilled.description', Lang.ENGLISH, 'Enable notifications of players kill manager script on getting killed')
t:register('enabledOnKilling', Lang.ENGLISH, 'Enabled on killing')
t:register('enabledOnKilling.description', Lang.ENGLISH, 'Enable notifications of players kill manager script on killing')
t:register('enableOnOtherKilling', Lang.ENGLISH, 'Enabled on other killing')
t:register('enableOnOtherKilling.description', Lang.ENGLISH, 'Enable notifications of players kill manager script on other killing')
t:register('notificationChannel', Lang.ENGLISH, 'Notification channel')
t:register('notificationChannel.description', Lang.ENGLISH, 'Notification channel of players kill manager script')

--- Kills
t:register('allKills', Lang.ENGLISH, 'All kills')
t:register('allKills.description', Lang.ENGLISH, 'All kills between players')
t:register('kills', Lang.ENGLISH, 'Kills')
t:register('kills.description', Lang.ENGLISH, 'Manage kills of players kill manager script')
t:register('allKillsOf', Lang.ENGLISH, 'All kills of %player%')
t:register('killsListOf', Lang.ENGLISH, 'Kills list of %player%')
t:register('playerKills', Lang.ENGLISH, '%player% kills')

t:register('killedAt', Lang.ENGLISH, 'Killed at: %date%')
t:register('victim', Lang.ENGLISH, 'Victim: %player%')
t:register('killer', Lang.ENGLISH, 'Killer: %player%')
t:register('weapon', Lang.ENGLISH, 'Weapon: %weapon%')
t:register('killerCar', Lang.ENGLISH, 'Killer car: %vehicle%')
t:register('victimCar', Lang.ENGLISH, 'Victim car: %vehicle%')
t:register('killerGodMode', Lang.ENGLISH, 'Killer god mode')
t:register('delete', Lang.ENGLISH, 'Delete')

--- Damages
t:register('damageInfos', Lang.ENGLISH, 'Damage infos')
t:register('damageInfos.description', Lang.ENGLISH, 'View damage infos of the kill')
t:register('from', Lang.ENGLISH, 'From: %player%')
t:register('to', Lang.ENGLISH, 'To: %player%')
t:register('damageAmount', Lang.ENGLISH, 'Damage amount: %damage%')
t:register('damageRoot', Lang.ENGLISH, '%player1% > %player2% : %damage%')

--- Players
t:register('playersList', Lang.ENGLISH, 'Players list')
t:register('playersList.description', Lang.ENGLISH, 'Manage players list')

--- Settings
t:register('settings', Lang.ENGLISH, 'Settings')
t:register('settings.description', Lang.ENGLISH, 'Manage settings of players kill manager script')
t:register('debug', Lang.ENGLISH, 'Debug')
t:register('debug.description', Lang.ENGLISH, 'Enable debug of players kill manager script')
t:register('onlyMe', Lang.ENGLISH, 'Only me')
t:register('onlyMe.description', Lang.ENGLISH, 'Only log kill of yourself')
t:register('enableDeleteButton', Lang.ENGLISH, 'Enable delete button')
t:register('enableDeleteButton.description', Lang.ENGLISH, 'Enable delete button')
t:register('reload', Lang.ENGLISH, 'Reload script')
t:register('reload.description', Lang.ENGLISH, 'Reload players kill manager script')

t:register('killedWith', Lang.ENGLISH, '%player1% killed %player2% with %weapon%')

t:register('aboveMap', Lang.ENGLISH, 'above map')
t:register('console', Lang.ENGLISH, 'console')
t:register('consoleDefault', Lang.ENGLISH, 'console + default')
t:register('file', Lang.ENGLISH, 'file')
t:register('web', Lang.ENGLISH, 'web')
t:register('chat', Lang.ENGLISH, 'chat')
t:register('chatTeam', Lang.ENGLISH, 'chat team')
t:register('default', Lang.ENGLISH, 'default')
t:register('logger', Lang.ENGLISH, 'logger')
t:register('all', Lang.ENGLISH, 'all')

--- Commands
t:register('commands.allKills', Lang.ENGLISH, 'allKills')
t:register('commands.playersKillList', Lang.ENGLISH, 'playersKillList')
t:register('commands.playersManager', Lang.ENGLISH, 'playersManager')
t:register('commands.playersManagerNotifications', Lang.ENGLISH, 'playersManagerNotifications')
t:register('commands.playersManagerEnableNotifications', Lang.ENGLISH, 'playersManagerEnableNotifications')
t:register('commands.playersManagerEnableNotificationsOnGettingKilled', Lang.ENGLISH, 'playersManagerEnableNotificationsOnGettingKilled')
t:register('commands.playersManagerEnableNotificationsOnKilling', Lang.ENGLISH, 'playersManagerEnableNotificationsOnKilling')
t:register('commands.playersManagerEnableNotificationsOnOtherKilling', Lang.ENGLISH, 'playersManagerEnableNotificationsOnOtherKilling')
t:register('commands.playersManagerSettings', Lang.ENGLISH, 'playersManagerSettings')
t:register('commands.playersManagerOnlyMe', Lang.ENGLISH, 'playersManagerOnlyMe')
t:register('commands.playersManagerEnableDeleteButton', Lang.ENGLISH, 'playersManagerEnableDeleteButton')
t:register('commands.kills', Lang.ENGLISH, 'kills')
t:register('commands.playerKills', Lang.ENGLISH, 'playerKills')
t:register('commands.playersManagerLang', Lang.ENGLISH, 'playersManagerLang')

-- Spanish
--- Usefull
t:register('goToPlayerTabs', Lang.SPANISH_CASTILIAN, 'Ir a las pestañas de los jugadores')
t:register('killRoot', Lang.SPANISH_CASTILIAN, '%player1% > %player2%')

--- Notifications
t:register('notifications', Lang.SPANISH_CASTILIAN, 'Notificaciones')
t:register('notifications.description', Lang.SPANISH_CASTILIAN, 'Gestionar las notificaciones de los jugadores que matan')
t:register('enabled', Lang.SPANISH_CASTILIAN, 'Activado')
t:register('enabled.description', Lang.SPANISH_CASTILIAN, 'Activar las notificaciones de los jugadores que matan')
t:register('enabledOnGettingKilled', Lang.SPANISH_CASTILIAN, 'Activado al morir')
t:register('enabledOnGettingKilled.description', Lang.SPANISH_CASTILIAN, 'Habilitar las notificaciones de los jugadores al ser asesinado')
t:register('enabledOnKilling', Lang.SPANISH_CASTILIAN, 'Activar al matar')
t:register('enabledOnKilling.description', Lang.SPANISH_CASTILIAN, 'Habilita las notificaciones cuando matas a otra persona')
t:register('enableOnOtherKilling', Lang.SPANISH_CASTILIAN, 'Activar cuando otra persona mate')
t:register('enableOnOtherKilling.description', Lang.SPANISH_CASTILIAN, 'Habilita las notificaciones cuando un jugador mate a otra persona')
t:register('notificationChannel', Lang.SPANISH_CASTILIAN, 'Canal de notificacion')
t:register('notificationChannel.description', Lang.SPANISH_CASTILIAN, 'Canal de notificacion')

--- Kills
t:register('allKills', Lang.SPANISH_CASTILIAN, 'Todas las muertes')
t:register('allKills.description', Lang.SPANISH_CASTILIAN, 'Todas las muertes entre jugadores')
t:register('kills', Lang.SPANISH_CASTILIAN, 'Kills')
t:register('kills.description', Lang.SPANISH_CASTILIAN, 'Gestionar kills de jugadores')
t:register('allKillsOf', Lang.SPANISH_CASTILIAN, 'Todas las kills de %player%')
t:register('killsListOf', Lang.SPANISH_CASTILIAN, 'Lista de todas las Kills de %player%')
t:register('playerKills', Lang.SPANISH_CASTILIAN, '%player% kills')

t:register('killedAt', Lang.SPANISH_CASTILIAN, 'Lo ha matado a las: %date%')
t:register('victim', Lang.SPANISH_CASTILIAN, 'Victima: %player%')
t:register('killer', Lang.SPANISH_CASTILIAN, 'Asesino: %player%')
t:register('weapon', Lang.SPANISH_CASTILIAN, 'Arma: %weapon%')
t:register('killerCar', Lang.SPANISH_CASTILIAN, 'Coche asesino: %vehicle%')
t:register('victimCar', Lang.SPANISH_CASTILIAN, 'Victima del atropellamiento: %vehicle%')
t:register('killerGodMode', Lang.SPANISH_CASTILIAN, 'Asesino en God Mode (Modo Dios)')
t:register('delete', Lang.SPANISH_CASTILIAN, 'Suprimir')
-- Aqui pa' arriba ya ta
--- Damages
t:register('damageInfos', Lang.SPANISH_CASTILIAN, 'Informacion del Daño')
t:register('damageInfos.description', Lang.SPANISH_CASTILIAN, 'Ver informacion del daño de la kill')
t:register('from', Lang.SPANISH_CASTILIAN, 'De: %player%')
t:register('to', Lang.SPANISH_CASTILIAN, 'A: %player%')
t:register('damageAmount', Lang.SPANISH_CASTILIAN, 'Cantidad de daño: %damage%')
t:register('damageRoot', Lang.SPANISH_CASTILIAN, '%player1% > %player2% : %damage%')

--- Players
t:register('playersList', Lang.SPANISH_CASTILIAN, 'Lista de jugadores')
t:register('playersList.description', Lang.SPANISH_CASTILIAN, 'Gestionar jugadores de la lista')

--- Settings
t:register('settings', Lang.SPANISH_CASTILIAN, 'Configuracion')
t:register('settings.description', Lang.SPANISH_CASTILIAN, 'Gestionar la configuración de los jugadores al matar')
t:register('debug', Lang.SPANISH_CASTILIAN, 'Debug')
t:register('debug.description', Lang.SPANISH_CASTILIAN, 'Habilitar la depuración de los jugadores al matar')
t:register('onlyMe', Lang.SPANISH_CASTILIAN, 'Solo yo')
t:register('onlyMe.description', Lang.SPANISH_CASTILIAN, 'Solo registrar cuando te matan')
t:register('enableDeleteButton', Lang.SPANISH_CASTILIAN, 'Activar el botón de suprimirn')
t:register('enableDeleteButton.description', Lang.SPANISH_CASTILIAN, 'Activar el botón de suprimir')
t:register('reload', Lang.SPANISH_CASTILIAN, 'Recargar Script')
t:register('reload.description', Lang.SPANISH_CASTILIAN, 'Recarga el script')

t:register('killedWith', Lang.SPANISH_CASTILIAN, '%player1% asesinado %player2% con %weapon%')

t:register('aboveMap', Lang.SPANISH_CASTILIAN, 'Mapa superior')
t:register('console', Lang.SPANISH_CASTILIAN, 'consola')
t:register('consoleDefault', Lang.SPANISH_CASTILIAN, 'consola + predeterminado')
t:register('file', Lang.SPANISH_CASTILIAN, 'archivo')
t:register('web', Lang.SPANISH_CASTILIAN, 'web')
t:register('chat', Lang.SPANISH_CASTILIAN, 'chat')
t:register('chatTeam', Lang.SPANISH_CASTILIAN, 'chat de equipo')
t:register('default', Lang.SPANISH_CASTILIAN, 'predeterminado')
t:register('logger', Lang.SPANISH_CASTILIAN, 'registrador')
t:register('all', Lang.SPANISH_CASTILIAN, 'todo')

--- Commands
t:register('commands.allKills', Lang.SPANISH_CASTILIAN, 'TodaslasKills')
t:register('commands.playersKillList', Lang.SPANISH_CASTILIAN, 'ListadeKillsdeJugadores')
t:register('commands.playersManager', Lang.SPANISH_CASTILIAN, 'Gestionarjugadores')
t:register('commands.playersManagerNotifications', Lang.SPANISH_CASTILIAN, 'GestionarNotificacionesdejugadores')
t:register('commands.playersManagerEnableNotifications', Lang.SPANISH_CASTILIAN, 'HabilitarNotificaciones')
t:register('commands.playersManagerEnableNotificationsOnGettingKilled', Lang.SPANISH_CASTILIAN, 'Habilitarnotificacionesalsereliminado')
-- PARA BAJO NO ESTA TRADUCIDO
t:register('commands.playersManagerEnableNotificationsOnKilling', Lang.SPANISH_CASTILIAN, 'Habilitarnotificacionesalmatar')
t:register('commands.playersManagerEnableNotificationsOnOtherKilling', Lang.SPANISH_CASTILIAN, 'Habilitarnotificacionescuandomatanaalguien')
t:register('commands.playersManagerSettings', Lang.SPANISH_CASTILIAN, 'Configuracion')
t:register('commands.playersManagerOnlyMe', Lang.SPANISH_CASTILIAN, 'Gestionar Jugadores OnlyMe')
t:register('commands.playersManagerEnableDeleteButton', Lang.SPANISH_CASTILIAN, 'Habilitarbotondesuprimir')
t:register('commands.kills', Lang.SPANISH_CASTILIAN, 'kills')
t:register('commands.playerKills', Lang.SPANISH_CASTILIAN, 'Killsdejugadores')

-- MenuWrapper
pluto_class MenuWrapper
    function __construct(root, menu_name_key, command_names_key, help_text_key, options_key, transform_menu_name, transform_command_names, transform_help_text, transform_options): userdata
        self.root = root
        self.transform_menu_name = transform_menu_name
        self.transform_command_names = transform_command_names
        self.transform_help_text = transform_help_text
        self.transform_options = transform_options
        self.menu_name_key = menu_name_key
        self.command_names_key = command_names_key
        self.help_text_key = help_text_key
        self.options_key = options_key
        self.commandsRefs = {}
    end

    function shadow_root(): userdata
        return self:build(menu.shadow_root())
    end

    function callTransform(menu_name, command_names, help_text, options): void
        if self.transform_menu_name ~= nil and menu_name ~= "" and menu_name ~= nil then
            menu_name = self.transform_menu_name(menu_name)
        end
        if self.transform_command_names ~= nil and type(command_names) == 'table' and table.getn(command_names) > 0 and command_names ~= nil then
            command_names = self.transform_command_names(command_names)
        end
        if self.transform_help_text ~= nil and help_text ~= "" and help_text ~= nil then
            help_text = self.transform_help_text(help_text)
        end
        if self.transform_options ~= nil and type(options) == 'table' and table.getn(options) > 0 and options ~= nil then
            options = self.transform_options(options)
        end
        return menu_name, command_names, help_text, options
    end

    function build(commandRef, menu_name_key, command_names_key, help_text_key, options_key): userdata
        return pluto_new MenuWrapper(commandRef, menu_name_key, command_names_key, help_text_key, options_key, self.transform_menu_name, self.transform_command_names, self.transform_help_text, self.transform_options)
    end

    function list(menu_name, command_names = {}, help_text = "", on_click = nil, on_back = nil, on_active_list_update = nil): userdata
        menu_name_translated, command_names_translated, help_text_translated = self:callTransform(menu_name, command_names, help_text)
        local list = self:build(self.root:list(menu_name_translated, command_names_translated, help_text_translated, on_click, on_back, on_active_list_update), menu_name, command_names, help_text)
        self.commandsRefs[#self.commandsRefs + 1] = list
        return list
    end

    function list_select(menu_name, command_names, help_text, options, default_value, on_change)
        menu_name_translated, command_names_translated, help_text_translated, options_translated = self:callTransform(menu_name, command_names, help_text, options)
        local list_select = self:build(self.root:list_select(menu_name_translated, command_names_translated, help_text_translated, options_translated, default_value, on_change), menu_name, command_names, help_text, options)
        self.commandsRefs[#self.commandsRefs + 1] = list_select
        return list_select
    end

    function toggle(menu_name, command_names, help_text, on_change, default_on = false)
        menu_name_translated, command_names_translated, help_text_translated = self:callTransform(menu_name, command_names, help_text)
        local toggle = self:build(self.root:toggle(menu_name_translated, command_names_translated, help_text_translated, on_change, default_on), menu_name, command_names, help_text)
        self.commandsRefs[#self.commandsRefs + 1] = toggle
        return toggle
    end

    function action(menu_name, command_names, help_text, on_click, on_command = nil, syntax = nil, perm = COMMANDPERM_USERONLY)
        menu_name_translated, command_names_translated, help_text_translated = self:callTransform(menu_name, command_names, help_text)
        local action = self:build(self.root:action(menu_name_translated, command_names_translated, help_text_translated, on_click, on_command, syntax, perm), menu_name, command_names, help_text)
        self.commandsRefs[#self.commandsRefs + 1] = action
        return action
    end

    function divider(key): userdata
        divider_name = self.transform_menu_name(key)
        self.root:divider(divider_name)
    end

    function getChildren(): userdata
        return self.root:getChildren()
    end

    function getRoot(): userdata
        return self.root
    end

    function setRoot(root): void
        self.root = root
    end

    function attach(otherRoot): userdata
        otherRoot:setRoot(self.root:attach(otherRoot:getRoot()))
        return otherRoot
    end

    function attachBefore(otherRoot): userdata
        self.root = menu.attach_before(otherRoot, self.root)
        return self
    end

    function updateTranslations(): void
        menu_name, command_names, help_text, options = self:callTransform(self.menu_name_key, self.command_names_key, self.help_text_key, self.options_key)
        if menu_name ~= "" and menu_name ~= nil then
            self.root.menu_name = menu_name
        end
        if type(command_names) == 'table' and table.getn(command_names) > 0 and command_names ~= nil then
            self.root.command_names = command_names
        end
        if help_text ~= "" and help_text ~= nil then
            self.root.help_text = help_text
        end
        if type(options) == 'table' and table.getn(options) > 0 then
            self.root:setListActionOptions(options)
        end
        for self.commandsRefs as command do
            command:updateTranslations()
        end
    end

    function link(otherRoot): userdata
        self.root:link(otherRoot:getRoot())
        return self
    end

    function delete(): void
        for self.commandsRefs as command do
            command:delete()
        end
        self.root:delete()
    end
end

function translate(key: string): string
    if type(key) == 'table' then
        return t:translate(table.unpack(key))
    else
        return t:translate(key)
    end
end

function translateCommand(keys)
    local translatedKeys = {}
    for keys as key do
        translatedKeys[#translatedKeys + 1] = translate(key)
    end
    return translatedKeys
end

function translateOptions(keys)
    local translatedKeys = {}
    for key, value in pairs(keys) do
        translatedKeys[key] = translate(value)
    end
    return translatedKeys
end

local root = pluto_new MenuWrapper(menu.my_root(), "", "", "", "", translate, translateCommand, translate, translateOptions)

-- Notifications manager
pluto_class NotificationsManager
    function __construct(): userdata
        self.enabled = false
        self.enabledOnGettingKilled = false
        self.enabledOnKilling = false
        self.enabledOnOtherKilling = false
        self.toastMode = TOAST_DEFAULT

        self:populateRoot()
    end

    function populateRoot(): void
        self.root = root:list('notifications', {'commands.playersManagerNotifications'}, 'notifications.description')
        self.root:toggle('enabled', {'commands.playersManagerEnableNotifications'}, 'enabled.description', || -> self:toggle(), self.enabled)
        self.root:toggle('enabledOnGettingKilled', {'commands.playersManagerEnableNotificationsOnGettingKilled'}, 'enabledOnGettingKilled.description', || -> self:toggleOnGettingKilled(), self.enabledOnGettingKilled)
        self.root:toggle('enabledOnKilling', {'commands.playersManagerEnableNotificationsOnKilling'}, 'enabledOnKilling.description', || -> self:toggleOnKilling(), self.enabledOnKilling)
        self.root:toggle('enableOnOtherKilling', {'commands.playersManagerEnableNotificationsOnOtherKilling'}, 'enableOnOtherKilling.description', || -> self:toggleOnOtherKilling(), self.enabledOnOtherKilling)
        self.root:list_select('notificationChannel', {}, "", {
            [TOAST_ABOVE_MAP] = {'aboveMap'},
            [TOAST_CONSOLE] = {'console'},
            [TOAST_CONSOLE+TOAST_DEFAULT] = {'consoleDefault'},
            [TOAST_FILE] = {'file'},
            [TOAST_WEB] = {'web'},
            [TOAST_CHAT] = {'chat'},
            [TOAST_CHAT_TEAM] = {'chatTeam'},
            [TOAST_DEFAULT] = {'default'},
            [TOAST_LOGGER] = {'logger'},
            [TOAST_ALL] = {'all'},
        }, self.toastMode, |value|-> self:setToastMode(value))
    end

    function destroy(): void
        self.root:delete()
    end

    function reload(): void
        self:destroy()
        self:populateRoot()
    end

    function notifyKill(victim: userdata, killer: userdata, weaponName: string): ?void
        if self.enabled then
            if victim:isMe() and not self.enabledOnGettingKilled then
                return;
            end
            if killer:isMe() and not self.enabledOnKilling then
                return;
            end
            if not killer:isMe() and not victim:isMe() and not self.enabledOnOtherKilling then
                return;
            end
            self:notify(t:translate('killedWith', {player1 = killer:getPlayerName(), player2 = victim:getPlayerName(), weapon = weaponName}))
        end
    end

    function notify(message: string): void
        if self.enabled then
            util.toast(message, self.toastMode)
        end
    end

    function toggle(): void
        self.enabled = not self.enabled
    end

    function getEnabled(): bool
        return self.enabled
    end

    function toggleOnGettingKilled(): void
        self.enabledOnGettingKilled = not self.enabledOnGettingKilled
    end

    function getEnabledOnGettingKilled(): bool
        return self.enabledOnGettingKilled
    end

    function toggleOnKilling(): void
        self.enabledOnKilling = not self.enabledOnKilling
    end

    function getEnabledOnKilling(): bool
        return self.enabledOnKilling
    end

    function toggleOnOtherKilling(): void
        self.enabledOnOtherKilling = not self.enabledOnOtherKilling
    end

    function getEnabledOnOtherKilling(): bool
        return self.enabledOnOtherKilling
    end

    function setToastMode(toastMode: int): void
        self.toastMode = toastMode
    end
end

pluto_class SettingsManager
    function __construct(): userdata
        self.debug = false
        self.onlyMe = false
        self.enableDeleteButton = false
        self.language = Lang.ENGLISH
        self:populateRoot()
    end

    function populateRoot(): void
        self.settingsRoot = root:list('settings', {'commands.playersManagerSettings'}, 'settings.description')
        -- self.settingsRoot:toggle("Debug", {"playersManagerDebug"}, "Enable debug of players kill manager script", || -> self:toggleDebug(), self.debug)
        self.settingsRoot:toggle('onlyMe', {'commands.playersManagerOnlyMe'}, 'onlyMe.description', || -> self:toggleOnlyMe(), self.onlyMe)
        self.settingsRoot:toggle('enableDeleteButton', {'commands.playersManagerEnableDeleteButton'}, 'enableDeleteButton.description', || -> self:toggleEnableDeleteButton(), self.enableDeleteButton)
        self.settingsRoot:list_select('language', {'commands.playersManagerLang'}, 'language.description', {[Lang.ENGLISH] = {"english"}, [Lang.SPANISH_CASTILIAN] = {"spanishCastilian"}}, self.language, |value|-> self:setLanguage(value))
        self.settingsRoot:action('reload', {}, 'reload.description', || -> util.restart_script())
    end

    function destroy(): void
        self.settingsRoot:delete()
    end

    function reload(): void
        self:destroy()
        self:populateRoot()
    end

    function toggleDebug(): void
        self.debug = not self.debug
    end

    function getDebug(): bool
        return self.debug
    end

    function toggleOnlyMe(): void
        self.onlyMe = not self.onlyMe
    end

    function getOnlyMe(): bool
        return self.onlyMe
    end

    function toggleEnableDeleteButton(): void
        self.enableDeleteButton = not self.enableDeleteButton
    end

    function getEnableDeleteButton(): bool
        return self.enableDeleteButton
    end

    function setLanguage(language: int): void
        self.language = language
        t:setLang(language)
        reload()
    end
end

pluto_class EventManager
    function __construct(): userdata
        self.events = {}
    end

    function destroy(): void
    end

    function reload(): void
        self:destroy()
    end

    function addEventListener(eventId: int, eventGroup: int, eventDataSize: int, callback: function): void
        if not self.events[eventId] then
            self.events[eventId] = {}
        end
        self.events[eventId][#self.events[eventId] + 1] = {['eventGroup'] = eventGroup, ['eventDataSize'] = eventDataSize, ['callback'] = callback}
    end

    function watch()
        for eventNum = 0, SCRIPT.GET_NUMBER_OF_EVENTS(1) - 1 do
            local eventId = SCRIPT.GET_EVENT_AT_INDEX(1, eventNum)
            if self.events[eventId] then
                for self.events[eventId] as event do
                    local eventData = memory.alloc(event['eventDataSize'] * 8)
                    if SCRIPT.GET_EVENT_DATA(1, eventNum, eventData, event['eventDataSize']) then
                        event['callback'](eventData)
                    end
                end
            end
        end
    end
end

-- Kill class
pluto_class Kill
    function __construct(killRootParent: userdata, victim: userdata, killer: userdata, weaponHash: int, damages: userdata): userdata
        self.killRoot = root:shadow_root():list({'killRoot', {player1 = killer:getPlayerName(), player2 = victim:getPlayerName()}}, {}, "", || -> self:addOrRemoveDeleteAction())
        local firstParentChild = killRootParent:getChildren()[1]
        if firstParentChild ~= nil then
            self.killRoot:attachBefore(firstParentChild)
        else
            self.killRoot = killRootParent:attach(self.killRoot)
        end
        self.victim = victim
        self.killer = killer
        self.weaponHash = weaponHash
        self.damages = damages
        self.deleteAction = nil
        self.linkList = {}

        notificationsManager:notifyKill(self.victim, self.killer, self:getWeaponName())

        self:populateKillRoot(self.killRoot)
    end

    function populateKillRoot(killRoot): void
        -- Populate kill root with the infos
        local victimName = self.victim:getPlayerName()
        local killerName = self.killer:getPlayerName()
        killRoot:action({'killedAt', {date = os.date("%H:%M:%S")}}, {}, "", function() end, function() end)
        killRoot:action({'victim', {player = victimName}}, {}, 'goToPlayerTabs', function() menu.trigger_commands('p ' .. victimName) end, function() end)
        killRoot:action({'killer', {player = killerName}}, {}, 'goToPlayerTabs', function() menu.trigger_commands('p ' .. killerName) end, function() end)
        killRoot:action({'weapon', {weapon = self:getWeaponName()}}, {}, "", function() end, function() end)
        local killerVehicle = self.killer:getPlayerCarName()
        if(killerVehicle~=nil) then
            killRoot:action({'killerCar', {vehicle = killerVehicle}}, {}, "", function() end, function() end)
        end
        local victimVehicle = self.victim:getPlayerCarName()
        if(victimVehicle~=nil) then
            killRoot:action({'victimCar', {vehicle = victimVehicle}}, {}, "", function() end, function() end)
        end
        killRoot:toggle('killerGodMode', {}, "", function() end, self.killer:isInGodMode())
        local damagesRoot = killRoot:list('damageInfos', {}, 'damageInfos.description')
        self:addOrRemoveDeleteAction()
        util.execute_in_os_thread(function()
            for self.damages as damage do
                damage:populateRoot(damagesRoot)
            end
        end)
    end

    function addOrRemoveDeleteAction(): void
        if settingsManager:getEnableDeleteButton() then
            if(self.deleteAction==nil) then
                self.deleteAction = self.killRoot:action('delete', {}, "", function() self:destroy() end, function() end)
            end
        else
            if(self.deleteAction~=nil) then
                self.deleteAction:delete()
                self.deleteAction = nil
            end
        end
    end

    function getKillRoot(): userdata
        -- Get kill root
        return self.killRoot
    end

    function getVictim(): userdata
        -- Get victim
        return self.victim
    end

    function getKiller(): userdata
        -- Get killer
        return self.killer
    end

    function getWeaponHash(): int
        -- Get weapon hash
        return self.weaponHash
    end

    function isVictim(victim: userdata): bool
        -- Check if victim is equal to the player
        return self.victim == victim:getPlayerId()
    end

    function isKiller(killer: userdata): bool
        -- Check if killer is equal to the player
        return self.killer == killer:getPlayerId()
    end

    function link(root: userdata)
        -- Link root to kill root
        local link = root:shadow_root():link(self.killRoot)
        local firstChild = root:getChildren()[1]
        if firstChild ~= nil then
            link:attachBefore(firstChild)
        else
            root:attach(link)
        end
        self.linkList[#self.linkList + 1] = link
    end

    function destroy(): void
        -- Delete kill
        self.killRoot:delete()
        for self.linkList as link do
            link:delete()
        end
    end

    function getWeaponName(): string
        -- Get weapon name
        local weapon = foundWeaponWithHash(self.weaponHash)
        -- If weapon is nil, return reversed hash
        if(weapon==nil) then
            return util.reverse_joaat(self.weaponHash)
        end
        -- Return weapon name from the game
        return util.get_label_text(weapon['label_key'])
    end
end

-- Damage class
pluto_class Damage
    function __construct(fromPlayer: userdata, toPlayer: userdata, weaponHash: int, damage: int): userdata
        self.fromPlayer = fromPlayer
        self.toPlayer = toPlayer
        self.damageAmount = damage
        self.weaponHash = weaponHash
    end

    function getFromPlayer(): userdata
        -- Get from player
        return self.fromPlayer
    end

    function getToPlayer(): userdata
        -- Get to player
        return self.toPlayer
    end

    function getDamageAmount(): int
        -- Get damage amount
        return self.damageAmount
    end

    function getWeaponHash(): int
        -- Get weapon hash
        return self.weaponHash
    end

    function populateRoot(root: userdata): void
        local rootList = root:list({'damageRoot', {player1 = self.fromPlayer:getPlayerName(), player2 = self.toPlayer:getPlayerName(), damage = string.format("%.2f", self.damageAmount)}}, {}, 'damageInfos')
        rootList:action({'from', {player = self.fromPlayer:getPlayerName()}}, {}, 'goToPlayerTabs', function() menu.trigger_commands('p ' .. self.fromPlayer:getPlayerName()) end, function() end)
        rootList:action({'to', {player = self.toPlayer:getPlayerName()}}, {}, 'goToPlayerTabs', function() menu.trigger_commands('p ' .. self.toPlayer:getPlayerName()) end, function() end)
        rootList:action({'weapon', {weapon = self:getWeaponName()}}, {}, "", function() end, function() end)
        rootList:action({'damageAmount', {damage = string.format("%.2f", self.damageAmount)}}, {}, "", function() end, function() end)
    end

    function getWeaponName(): string
        -- Get weapon name
        local weapon = foundWeaponWithHash(self.weaponHash)
        -- If weapon is nil, return reversed hash
        if(weapon==nil) then
            return util.reverse_joaat(self.weaponHash)
        end
        -- Return weapon name from the game
        return util.get_label_text(weapon['label_key'])
    end
end

-- Player class
pluto_class Player
    function __construct(player, playersManager): userdata
		self.player = player
        self.ped = PLAYER.GET_PLAYER_PED(player)
        self.damageBeforeDeath = {}
        self.playersManager = playersManager
        self.kills = {}
        self.playerKillsRoot = nil
        self:populateRoot()
	end

    function populateRoot(): void
        self.playerKillsRoot = playersRoot:list({'playerKills', {player = self:getPlayerName()}}, {{'commands.playerKills', {player = self:getPlayerName()}}}, {'allKillsOf', {player = self:getPlayerName()}})
    end

    function updateTranslations()
        if self.playerKillsRoot ~= nil then
            self.playerKillsRoot:updateTranslations()
        end
    end

    function reload(): void
        for self.kills as kill do
            kill:destroy()
        end
        self.kills = {}
        self:populateRoot()
    end

    function getPlayerId(): int
        -- Get player id
        return self.player
    end

    function getPlayerPed(): int
        -- Get player ped
        return self.ped
    end

    function getPlayerCar(): int
        -- Get player vehicle
        return players.get_vehicle_model(self.player)
    end

    function equal(player: userdata): bool
        -- Check if player is equal to another player
        return self.player == player:getPlayerId()
    end

    function isDead(): bool
        -- Check if player is dead
        return ENTITY.IS_ENTITY_DEAD(self.ped)
    end

    function isMe(): bool
        -- Check if player is me
        return self.player == players.user()
    end

    function isInGodMode(): bool
        -- Check if player is in god mode
        return players.is_godmode(self.player)
    end

    function getPlayerName(): string
        -- Get player name
        return players.get_name(self.player)
    end

    function getPlayerCarName(): ?string
        -- Get player vehicle model
        local playerVehicleModel = self:getPlayerCar()
        -- If vehicle model is nil, return nil
        if(playerVehicleModel==nil or playerVehicleModel==0) then
            return nil
        end
        return util.get_label_text(VEHICLE.GET_DISPLAY_NAME_FROM_VEHICLE_MODEL(playerVehicleModel))
    end

    function destroy(): void
        -- Delete all kills on leave
        self.playerKillsRoot:delete()
    end

    function addPlayerDamage(otherPlayer: userdata, weaponHash: int, damage: int, isKiller: bool): void
        -- write damage in the good order
        local killer;
        local victim;
        if isKiller then
            killer = self
            victim = otherPlayer
        else
            killer = otherPlayer
            victim = self
        end
        local damage = pluto_new Damage(killer, victim, weaponHash, damage)
        self.damageBeforeDeath[#self.damageBeforeDeath + 1] = damage
    end

    function addPlayerKill(otherPlayer: userdata, weaponHash: int, damage: int, isKiller: bool): void
        self:addPlayerDamage(otherPlayer, weaponHash, damage, isKiller)
        -- write kill in the good order
        local killer;
        local victim;
        if isKiller then
            killer = self
            victim = otherPlayer
        else
            killer = otherPlayer
            victim = self
        end
        -- Create kill
        local kill;
        if isKiller then
            kill = pluto_new Kill(allKillsRoot, victim, killer, weaponHash, self.damageBeforeDeath)
        else
            kill = pluto_new Kill(self.playerKillsRoot, victim, killer, weaponHash, self.damageBeforeDeath)
        end
        -- Populate player kills root in player tabs
        kill:link(self.playerKillsRootInStand)

        -- Remember kill
        self.kills[#self.kills + 1] = kill
        self.damageBeforeDeath = {}
    end

    function getPlayerKiller(): ?table
        local weaponHash = memory.alloc(4)
        -- Find killer and weapon hash
        local killerId = NETWORK.NETWORK_GET_KILLER_OF_PLAYER(self.player, weaponHash)
        if(killerId ~= -1) then
            return {['killer'] = self.playersManager:getPlayer(killerId), ['weaponHash'] = memory.read_int(weaponHash)}
        else
            return nil
        end
    end

    function setPlayerKillsRootInStand(root): void
        self.playerKillsRootInStand = root
    end
end

-- Players manager class
pluto_class PlayersManager
    function __construct(players): userdata
        -- init players
        self.players = {}
        for players as playerId do
            local player = pluto_new Player(playerId, self)
            self.players[playerId] = player
        end
    end

    function destroy()
    end

    function updateTranslations()
        for self.players as player do
            player:updateTranslations()
        end
    end

    function reload()
        self:destroy()
        for self.players as player do
            player:reload()
        end
    end

    function getPlayers(): table
        return self.players
    end

    function getPlayer(playerId: int): userdata
        return self.players[playerId]
    end

    function addPlayer(playerId: int): void
        local player = pluto_new Player(playerId, self)
        self.players[playerId] = player
    end

    function removePlayer(playerId: int): void
        local player = self.players[playerId]
        player:destroy()
        self.players[playerId] = nil
    end

    function addPlayerKillers(): void
        for self.players as player do
            -- if player is dead
            if player:isDead() then
                -- get killer
                local kill = player:getPlayerKiller()

                -- if killer is not nil, add kill
                if kill ~= nil then
                    local killer = kill['killer']
                    local weaponHash = kill['weaponHash']
                    -- Do not duplicate kill
                    if(killer:equal(player)) then
                        player:addPlayerKill(killer, weaponHash, true)
                    else
                        player:addPlayerKill(killer, weaponHash, false)
                        killer:addPlayerKill(player, weaponHash, true)
                    end
                end
            end
        end
    end

    function getPlayersList()
        local playersList = {}
        for self.players as player do
            playersList[#playersList + 1] = t:translate('playerKills', {player = player:getPlayerName()})
        end
        return playersList
    end

    function manageDamageEvent(eventData)
        local victim = memory.read_int(eventData)
        local attacker = memory.read_int(eventData + 1 * 8)
        local damage = memory.read_float(eventData + 2 * 8)
        local victimDestroyed = memory.read_int(eventData + 5*8)
        local weaponUsedHash = memory.read_int(eventData + 6 * 8)

        if victim ~= -1 and attacker ~= -1 then
            local victimId = NETWORK.NETWORK_GET_PLAYER_INDEX_FROM_PED(victim)
            local attackerId = NETWORK.NETWORK_GET_PLAYER_INDEX_FROM_PED(attacker)
            if attackerId ~= -1 and victimId ~= -1 then
                local killer = self:getPlayer(attackerId)
                local victim = self:getPlayer(victimId)
                -- Ignore kill if settings only me is enabled and killer or victim are not me
                if settingsManager:getOnlyMe() and not killer:isMe() and not victim:isMe() then
                    return
                end
                if victimDestroyed == 1 then
                    if(killer:equal(victim)) then
                        killer:addPlayerKill(victim, weaponUsedHash, damage, true)
                    else
                        victim:addPlayerKill(killer, weaponUsedHash, damage, false)
                        killer:addPlayerKill(victim, weaponUsedHash, damage, true)
                    end
                elseif victimDestroyed == 0 then
                    if(killer:equal(victim)) then
                        killer:addPlayerDamage(victim, weaponUsedHash, damage, true)
                    else
                        victim:addPlayerDamage(killer, weaponUsedHash, damage, false)
                        killer:addPlayerDamage(victim, weaponUsedHash, damage, true)
                    end
                    -- Will add player damage history
                end
            end
        end
    end
end

function reload()
    --[[
    local oldAllKillsRoot = allKillsRoot
    allKillsRoot = root:list('allKills', {'commands.allKills'}, 'allKills.description')
    local oldPlayersRoot = playersRoot
    playersRoot = root:list('playersList', {'commands.playersKillList'}, 'playersList.description')

    notificationsManager:reload()
    settingsManager:reload()
    eventManager:reload()
    playersManager:reload()

    oldAllKillsRoot:delete()
    oldPlayersRoot:delete()
    --]]
    playersManager:updateTranslations()
    root:updateTranslations()
end

function init()
    allKillsRoot = root:list('allKills', {'commands.allKills'}, 'allKills.description')
    playersRoot = root:list('playersList', {'commands.playersKillList'}, 'playersList.description')

    -- Instantiate notifications manager / static instance
    notificationsManager = pluto_new NotificationsManager()

    -- Instantiate settings manager / static instance
    settingsManager = pluto_new SettingsManager(reload)

    -- Instantiate event manager / static instance
    eventManager = pluto_new EventManager()

    -- Instantiate players manager / static instance
    playersManager = pluto_new PlayersManager(players.list())

    -- Command builder to get player kills in player tabs
    function commandBuilder(playerId: int, playerRoot)
        local playerRoot = pluto_new MenuWrapper(playerRoot, "", "", "", "", translate, translateCommand, translate, translateOptions)
        local player = playersManager:getPlayer(playerId)
        playerRoot:divider('scriptName')
        local killList = playerRoot:list('kills', {'commands.kills'}, {'killsListOf', {player = player:getPlayerName()}})
        player:setPlayerKillsRootInStand(killList)
        return true
    end

    -- Add players to players manager
    players.on_join(|playerId| -> playersManager:addPlayer(playerId))

    -- Remove players from players manager
    players.on_leave(|playerId| -> playersManager:removePlayer(playerId))

    -- Add command hook to get player kills in player tabs
    players.add_command_hook(commandBuilder)

    eventManager:addEventListener(CEventNetworkEntityDamage, 1, 13, |eventData| -> playersManager:manageDamageEvent(eventData))
    
    -- Add tick handler to get player kills
    util.create_tick_handler(function()
        eventManager:watch()
    end)
end

init()

-- Add this just in case
util.keep_running()